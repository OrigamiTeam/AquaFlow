#include <Arduino.h>

#include "MAX35103.h"
#include "valvulaMotorDC.h"
#include "displayST7565R.h"

#include <avr/pgmspace.h>

// Pino para botao com acesso externo
#define btnPin 2

// Pinos para interface com MAX35103
#define MAX35103INT 3
#define MAX35103RST 4
#define MAX35103CE 10

// Pinos para acionamento do driver de motor DC e sensores fim de curso
#define SW1Pin 5
#define SW2Pin 6
#define motorSleepPin 7
#define motorIN1Pin 8
#define motorIN2Pin 9

// Pino para leitura analogica do sensor de pressao
#define pressaoPin 14

// Pinos para interface com display NHD-C12832A1Z-FSW-FBW-3V3
#define LCD_SI 15
#define LCD_SCL 16
#define LCD_A0 17
#define LCD_LED 23
#define LCD_RST 25
#define LCD_CS 26

// Pinos para interface externa com modulos de comunicacao (SPI compartilhado com SS dedicado, RS-232 dedicado e I2C dedicado)
#define RS232_RX_EXT 0
#define RX232_TX_EXT 1
#define I2C_SDA_EXT 18
#define I2C_SCL_EXT 19
#define SPI_SS_EXT 24

const unsigned char numeros [10][56] PROGMEM = {
  {0xF8, 0xF8, 0xF8, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0xF8, 0xF8, 0xF8, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x0F, 0x0F, 0x0F, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0F, 0x0F, 0x0F},
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0xF8, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x0F},
  {0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0xF8, 0xF8, 0xF8, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x0F, 0x0F, 0x0F, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E},
  {0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0xF8, 0xF8, 0xF8, 0x00, 0x00, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0xFF, 0xFF, 0xFF, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0F, 0x0F, 0x0F},
  {0xF8, 0xF8, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0xF8, 0xF8, 0xFF, 0xFF, 0xFF, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xFF, 0xFF, 0xFF, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x0F},
  {0xF8, 0xF8, 0xF8, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0xFF, 0xFF, 0xFF, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0xFF, 0xFF, 0xFF, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0F, 0x0F, 0x0F},
  {0xF8, 0xF8, 0xF8, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xFF, 0xFF, 0xFF, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0xFF, 0xFF, 0xFF, 0x0F, 0x0F, 0x0F, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0F, 0x0F, 0x0F},
  {0xF8, 0xF8, 0xF8, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0xF8, 0xF8, 0xF8, 0x3F, 0x3F, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x0F},
  {0xF8, 0xF8, 0xF8, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0xF8, 0xF8, 0xF8, 0xFF, 0xFF, 0xFF, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0xFF, 0xFF, 0xFF, 0x0F, 0x0F, 0x0F, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0F, 0x0F, 0x0F},
  {0xF8, 0xF8, 0xF8, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0xF8, 0xF8, 0xF8, 0xFF, 0xFF, 0xFF, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xFF, 0xFF, 0xFF, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0F, 0x0F, 0x0F}
};

const unsigned char simbolos [2][60] PROGMEM = {
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x0E},
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x60, 0x60, 0x60, 0xE0, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x60, 0x66, 0x66, 0x7F, 0x7F, 0xFE, 0xFE, 0x06, 0x06, 0x06, 0xFE, 0xFE, 0x06, 0x06, 0x06, 0xFE, 0xFE, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x00, 0x00, 0x00}
};

unsigned long leituraAnterior = 0;

MAX35103 MAX;
valvulaMotorDC valvula;
displayST7565R LCD;

// DISPLAY

void PGMReadNumber(unsigned char *_vetor, uint8_t _posicao) {
  for (uint8_t _i = 0; _i < 56; _i++) {
    _vetor[_i] = pgm_read_byte(&(numeros[_posicao][_i]));
  }
}

void PGMreadSymbol(unsigned char *_vetor, uint8_t _numero, uint8_t _tamanho) {
  for (uint8_t _i = 0; _i < _tamanho; _i++) {
    _vetor[_i] = pgm_read_byte(&(simbolos[_numero][_i]));
  }
}

// _volumeInt deve ser um numero uint32_t formado pelo fluxo em float multiplicado por 10, ou seja, a unidade sera exibida como casa decimal
void volumeLCD(uint32_t _volumeInt) {
  String _volumeString = "";

  if (_volumeInt < 100000) {
    _volumeString.concat("0");
  }
  if (_volumeInt < 10000) {
    _volumeString.concat("0");
  }
  if (_volumeInt < 1000) {
    _volumeString.concat("0");
  }
  if (_volumeInt < 100) {
    _volumeString.concat("0");
  }
  if (_volumeInt < 10) {
    _volumeString.concat("0");
  }
  
  _volumeString.concat(_volumeInt);
  uint32_t _length = _volumeString.length();

  unsigned char _char [60] = {};

  PGMReadNumber(_char, _volumeString[_length - 6] - '0');
  LCD.writeNumber(_char, 0);

  PGMReadNumber(_char, _volumeString[_length - 5] - '0');
  LCD.writeNumber(_char, 18);
  
  PGMReadNumber(_char, _volumeString[_length - 4] - '0');
  LCD.writeNumber(_char, 36);
  
  PGMReadNumber(_char, _volumeString[_length - 3] - '0');
  LCD.writeNumber(_char, 54);
  
  PGMReadNumber(_char, _volumeString[_length - 2] - '0');
  LCD.writeNumber(_char, 72);

  // simbolo de . (ponto decimal)
  PGMreadSymbol(_char, 0, 8); // 8 bytes no vetor
  LCD.writeSymbol(_char, 89, 2); // 2 colunas no display
  
  PGMReadNumber(_char, _volumeString[_length - 1] - '0');
  LCD.writeNumber(_char, 94);
  
  // simbolo de m3 (metro cubico)
  PGMreadSymbol(_char, 1, 60); // 60 bytes no vetor
  LCD.writeSymbol(_char, 113, 15); // 15 colunas no display
}

void setup() {
  pinMode(LCD_LED, OUTPUT);
  digitalWrite(LCD_LED, LOW);

  pinMode(btnPin, INPUT);
  //digitalWrite(btnPin, HIGH); // Pullup externo

  pinMode(pressaoPin, INPUT);

  //MAX.begin(MAX35103INT, MAX35103RST, MAX35103CE);

  //valvula.begin(SW1Pin, SW2Pin, motorSleepPin, motorIN1Pin, motorIN2Pin);
  //valvula.abre();

  LCD.begin(LCD_SI, LCD_SCL, LCD_A0, LCD_RST, LCD_CS);
  delay(10);
  LCD.clear(0, 128);

  /////////////////////////////////////////////////
  digitalWrite(LCD_LED, HIGH);
  delay(100);
  
  volumeLCD(123456);
  delay(1500);
  LCD.clear(0, 128);
  delay(1);
  
  digitalWrite(LCD_LED, LOW);
  /////////////////////////////////////////////////

  /////////////////////////////////////////////////
  Serial.begin(115200);
  delay(100);

  Serial.println(F("\n\nIniciando..."));
  delay(100);
  /////////////////////////////////////////////////

  if (MAX.reset()) {
    Serial.println(F("MAX35103 Reset OK!"));
  }
  else {
    Serial.println(F("ERRO no Reset do MAX35103"));
  }

  delay(500);

  /*uint16_t _dado = readFlash16(0x0000);
  Serial.print("_dado: ");
  Serial.println(_dado, HEX);
  delay(500);

  eraseFlash(0x0000);
  delay(100);

  while (interruptStatus(7) == 0) {
    delay(100);
  }
  Serial.println("Erase OK!");

  delay(500);

  _dado = readFlash16(0x0000);
  Serial.print("_dado: ");
  Serial.println(_dado, HEX);
  delay(500);

  writeFlash16(0x0000, 0x1234);
  delay(100);

  while (interruptStatus(7) == 0) {
    delay(100);
  }
  Serial.println("Write OK!");

  delay(500);

  _dado = readFlash16(0x0000);
  Serial.print("_dado: ");
  Serial.println(_dado, HEX);

  delay(500);*/
  
  MAX.config();

  uint16_t _reg = MAX.readRegister16(0xB8);
  Serial.print("TOF1 0xB8: ");
  Serial.print(_reg, BIN);
  Serial.print(" | 0x");
  Serial.println(_reg, HEX);

  _reg = MAX.readRegister16(0xB9);
  Serial.print("TOF2 0xB9: ");
  Serial.print(_reg, BIN);
  Serial.print(" | 0x");
  Serial.println(_reg, HEX);

  _reg = MAX.readRegister16(0xBA);
  Serial.print("TOF3 0xBA: ");
  Serial.print(_reg, BIN);
  Serial.print(" | 0x");
  Serial.println(_reg, HEX);

  _reg = MAX.readRegister16(0xBB);
  Serial.print("TOF4 0xBB: ");
  Serial.print(_reg, BIN);
  Serial.print(" | 0x");
  Serial.println(_reg, HEX);

  _reg = MAX.readRegister16(0xBC);
  Serial.print("TOF5 0xBC: ");
  Serial.print(_reg, BIN);
  Serial.print(" | 0x");
  Serial.println(_reg, HEX);

  _reg = MAX.readRegister16(0xBD);
  Serial.print("TOF5 0xBD: ");
  Serial.print(_reg, BIN);
  Serial.print(" | 0x");
  Serial.println(_reg, HEX);

  _reg = MAX.readRegister16(0xBE);
  Serial.print("TOF5 0xBE: ");
  Serial.print(_reg, BIN);
  Serial.print(" | 0x");
  Serial.println(_reg, HEX);

  _reg = MAX.readRegister16(0xC0);
  Serial.print("_reg 0xC0: ");
  Serial.print(_reg, BIN);
  Serial.print(" | 0x");
  Serial.println(_reg, HEX);

  _reg = MAX.readRegister16(0xC1);
  Serial.print("_reg 0xC1: ");
  Serial.print(_reg, BIN);
  Serial.print(" | 0x");
  Serial.println(_reg, HEX);

  _reg = MAX.readRegister16(0xC2);
  Serial.print("_reg 0xC2: ");
  Serial.print(_reg, BIN);
  Serial.print(" | 0x");
  Serial.println(_reg, HEX);

  delay(500);

  if (MAX.toFlash()) {
    Serial.println(F("MAX35103 toFlash OK!"));
  }
  else {
    Serial.println(F("ERRO no toFlash do MAX35103"));
  }
  
  delay(500);

  if (MAX.initialize()) {
    Serial.println(F("Initialize OK!"));
  }
  else {
    Serial.println(F("ERRO no initialize do MAX35103"));
  }
}

void loop() {
  if (millis() > leituraAnterior + 1000) {
    leituraAnterior = millis();

    float _fluxo = 0.0;
    if (MAX.fluxoToFDIff(&_fluxo)) {
      Serial.print(F("Fluxo: "));
      Serial.println(_fluxo, 2);
    }
    else {
      Serial.println(F("Erro ao ler fluxo!"));
    }

    float _temperatura1 = 0.0;
    if (MAX.temperatura(1, &_temperatura1)) {
      Serial.print(F("Temp1: "));
      Serial.println(_temperatura1, 1);
    }
    else {
      Serial.println(F("Erro ao ler temperatura!"));
    }

    uint32_t _pressaoAnalog = analogRead(pressaoPin);
    uint32_t _pressaoBarInt = map(_pressaoAnalog, 95, 870, 0, 690);
    float _pressaoBar = (float)_pressaoBarInt / 100.0;

    Serial.print("_pressao: ");
    Serial.print(_pressaoAnalog);
    Serial.print(" | ");
    Serial.print(_pressaoBar);
    Serial.println(" bar");

    if (_pressaoAnalog < 100) {
      Serial.println(F("### Ausencia de agua! ###"));
    }
  }

  delay(10);
}