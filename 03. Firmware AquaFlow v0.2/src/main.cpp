#include <Arduino.h>
#include <SPI.h>
#include <LoRa.h>
#include <avr/pgmspace.h>

#include "MAX35103.h"
#include "valvulaMotorDC.h"
#include "displayST7565R.h"

#define DEBUG true

// Pino para botao com acesso externo
#define btnPin 2

// Pinos para interface com MAX35103
#define MAX35103INT 3
#define MAX35103RST 4
#define MAX35103CE 10

// Pinos para acionamento do driver de motor DC e sensores fim de curso
#define SW1Pin 5
#define SW2Pin 6
#define motorSleepPin 7
#define motorIN1Pin 8
#define motorIN2Pin 9

// Pino para leitura analogica do sensor de pressao
#define pressaoPin 14

// Pinos para interface com display NHD-C12832A1Z-FSW-FBW-3V3
#define LCD_SI 15
#define LCD_SCL 16
#define LCD_A0 17
#define LCD_LED 23
#define LCD_RST 25
#define LCD_CS 26

// Pinos para interface externa com modulos de comunicacao (SPI compartilhado com SS dedicado, RS-232 dedicado e I2C dedicado)
#define RS232_RX_EXT 0
#define RX232_TX_EXT 1
#define I2C_SDA_EXT 18
#define I2C_SCL_EXT 19
#define SPI_SS_EXT 24

// ### MODULO LoRa ###

#define LoRaSS I2C_SDA_EXT
#define LoRaRST I2C_SCL_EXT
#define LoRaDIO0 SPI_SS_EXT

const unsigned char numeros [10][56] PROGMEM = {
  {0xF8, 0xF8, 0xF8, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0xF8, 0xF8, 0xF8, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x0F, 0x0F, 0x0F, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0F, 0x0F, 0x0F},
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0xF8, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x0F},
  {0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0xF8, 0xF8, 0xF8, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x0F, 0x0F, 0x0F, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E},
  {0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0xF8, 0xF8, 0xF8, 0x00, 0x00, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0xFF, 0xFF, 0xFF, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0F, 0x0F, 0x0F},
  {0xF8, 0xF8, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0xF8, 0xF8, 0xFF, 0xFF, 0xFF, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xFF, 0xFF, 0xFF, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x0F},
  {0xF8, 0xF8, 0xF8, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0xFF, 0xFF, 0xFF, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0xFF, 0xFF, 0xFF, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0F, 0x0F, 0x0F},
  {0xF8, 0xF8, 0xF8, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xFF, 0xFF, 0xFF, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0xFF, 0xFF, 0xFF, 0x0F, 0x0F, 0x0F, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0F, 0x0F, 0x0F},
  {0xF8, 0xF8, 0xF8, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0xF8, 0xF8, 0xF8, 0x3F, 0x3F, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x0F},
  {0xF8, 0xF8, 0xF8, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0xF8, 0xF8, 0xF8, 0xFF, 0xFF, 0xFF, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0xFF, 0xFF, 0xFF, 0x0F, 0x0F, 0x0F, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0F, 0x0F, 0x0F},
  {0xF8, 0xF8, 0xF8, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0xF8, 0xF8, 0xF8, 0xFF, 0xFF, 0xFF, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xFF, 0xFF, 0xFF, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0F, 0x0F, 0x0F}
};

const unsigned char simboloPonto [8] PROGMEM = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x0E};
const unsigned char simboloM3 [60] PROGMEM = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x60, 0x60, 0x60, 0xE0, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x60, 0x66, 0x66, 0x7F, 0x7F, 0xFE, 0xFE, 0x06, 0x06, 0x06, 0x7E, 0x7E, 0x06, 0x06, 0x06, 0xFE, 0xFE, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x00, 0x00, 0x00};
const unsigned char simboloLMin [168] PROGMEM = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0xFE, 0x1E, 0x00, 0x00, 0xFE, 0xFE, 0x06, 0x06, 0x06, 0x7E, 0x7E, 0x06, 0x06, 0x06, 0xFE, 0xFE, 0x00, 0x00, 0x00, 0xF6, 0xF6, 0x00, 0x00, 0x00, 0xFE, 0xFE, 0x06, 0x06, 0x06, 0xFE, 0xFE, 0x0F, 0x0F, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x00, 0x00, 0x0F, 0x0F, 0x01, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x0F, 0x0F};
const unsigned char simboloCelsius [48] PROGMEM = {0x38, 0x38, 0x38, 0x00, 0x00, 0xF8, 0xF8, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0x3F, 0x30, 0x30, 0x30, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
const unsigned char simboloBar [108] PROGMEM = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFE, 0x66, 0x66, 0x66, 0xFE, 0xFC, 0x00, 0x00, 0x00, 0xFE, 0xFE, 0x66, 0x66, 0x66, 0xFE, 0xFE, 0x00, 0x00, 0x00, 0xFE, 0xFE, 0xE6, 0xE6, 0xE6, 0x7E, 0x7E, 0x0F, 0x0F, 0x0C, 0x0C, 0x0C, 0x0F, 0x07, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x00, 0x01, 0x03, 0x0F, 0x0E};

unsigned long leituraAnterior = 0;

MAX35103 MAX;
valvulaMotorDC valvula;
displayST7565R LCD;

// ### INICIO MAX35103 ###

/*uint16_t _dado = readFlash16(0x0000);
  Serial.print("_dado: ");
  Serial.println(_dado, HEX);
  delay(500);

  eraseFlash(0x0000);
  delay(100);

  while (interruptStatus(7) == 0) {
    delay(100);
  }
  Serial.println("Erase OK!");

  delay(500);

  _dado = readFlash16(0x0000);
  Serial.print("_dado: ");
  Serial.println(_dado, HEX);
  delay(500);

  writeFlash16(0x0000, 0x1234);
  delay(100);

  while (interruptStatus(7) == 0) {
    delay(100);
  }
  Serial.println("Write OK!");

  delay(500);

  _dado = readFlash16(0x0000);
  Serial.print("_dado: ");
  Serial.println(_dado, HEX);

  delay(500);*/

#if DEBUG
void printConfigMAX() {
  uint16_t _reg = MAX.readRegister16(0xB8);
  Serial.print("TOF1 0xB8: 0x");
  Serial.println(_reg, HEX);

  _reg = MAX.readRegister16(0xB9);
  Serial.print("TOF2 0xB9: 0x");
  Serial.println(_reg, HEX);

  _reg = MAX.readRegister16(0xBA);
  Serial.print("TOF3 0xBA: 0x");
  Serial.println(_reg, HEX);

  _reg = MAX.readRegister16(0xBB);
  Serial.print("TOF4 0xBB: 0x");
  Serial.println(_reg, HEX);

  _reg = MAX.readRegister16(0xBC);
  Serial.print("TOF5 0xBC: 0x");
  Serial.println(_reg, HEX);

  _reg = MAX.readRegister16(0xBD);
  Serial.print("TOF5 0xBD: 0x");
  Serial.println(_reg, HEX);

  _reg = MAX.readRegister16(0xBE);
  Serial.print("TOF5 0xBE: 0x");
  Serial.println(_reg, HEX);

  _reg = MAX.readRegister16(0xC0);
  Serial.print("_reg 0xC0: 0x");
  Serial.println(_reg, HEX);

  _reg = MAX.readRegister16(0xC1);
  Serial.print("_reg 0xC1: 0x");
  Serial.println(_reg, HEX);

  _reg = MAX.readRegister16(0xC2);
  Serial.print("_reg 0xC2: 0x");
  Serial.println(_reg, HEX);
}
#endif

// ### FINAL MAX35103 ###

// ### INICIO DISPLAY ###

void PGMReadNumeros(unsigned char *_vetor, uint8_t _posicao) {
  for (uint8_t _i = 0; _i < 56; _i++) {
    _vetor[_i] = pgm_read_byte(&(numeros[_posicao][_i]));
  }
}

void PGMreadSimboloPonto(unsigned char *_vetor) {
  for (uint8_t _i = 0; _i < 8; _i++) {
    _vetor[_i] = pgm_read_byte(&(simboloPonto[_i]));
  }
}

void PGMreadSimboloM3(unsigned char *_vetor) {
  for (uint8_t _i = 0; _i < 60; _i++) {
    _vetor[_i] = pgm_read_byte(&(simboloM3[_i]));
  }
}

void PGMreadSimboloLMin(unsigned char *_vetor) {
  for (uint8_t _i = 0; _i < 168; _i++) {
    _vetor[_i] = pgm_read_byte(&(simboloLMin[_i]));
  }
}

void PGMreadSimboloCelsius(unsigned char *_vetor) {
  for (uint8_t _i = 0; _i < 48; _i++) {
    _vetor[_i] = pgm_read_byte(&(simboloCelsius[_i]));
  }
}

void PGMreadSimboloBar(unsigned char *_vetor) {
  for (uint8_t _i = 0; _i < 108; _i++) {
    _vetor[_i] = pgm_read_byte(&(simboloBar[_i]));
  }
}

// _volumeInt deve ser um numero uint32_t formado pelo volume em float multiplicado por 10, ou seja, a unidade sera exibida como casa decimal
void volumeLCD(uint32_t _volumeInt) {
  String _string = "";

  if (_volumeInt < 100000) {
    _string.concat("0");
  }
  if (_volumeInt < 10000) {
    _string.concat("0");
  }
  if (_volumeInt < 1000) {
    _string.concat("0");
  }
  if (_volumeInt < 100) {
    _string.concat("0");
  }
  if (_volumeInt < 10) {
    _string.concat("0");
  }
  
  _string.concat(_volumeInt);
  uint32_t _length = _string.length();

  unsigned char _char [60] = {};

  PGMReadNumeros(_char, _string[_length - 6] - '0');
  LCD.writeNumber(_char, 0);

  PGMReadNumeros(_char, _string[_length - 5] - '0');
  LCD.writeNumber(_char, 18);
  
  PGMReadNumeros(_char, _string[_length - 4] - '0');
  LCD.writeNumber(_char, 36);
  
  PGMReadNumeros(_char, _string[_length - 3] - '0');
  LCD.writeNumber(_char, 54);
  
  PGMReadNumeros(_char, _string[_length - 2] - '0');
  LCD.writeNumber(_char, 72);

  // simbolo de . (ponto decimal)
  PGMreadSimboloPonto(_char);
  LCD.writeSymbol(_char, 89, 2); // 2 colunas no display
  
  PGMReadNumeros(_char, _string[_length - 1] - '0');
  LCD.writeNumber(_char, 94);
  
  // simbolo de m3 (metro cubico)
  PGMreadSimboloM3(_char);
  LCD.writeSymbol(_char, 113, 15); // 15 colunas no display
}

// _fluxoInt deve ser um numero uint32_t formado pelo fluxo em float multiplicado por 10, ou seja, a unidade sera exibida como casa decimal
void fluxoLCD(uint32_t _fluxoInt, uint8_t _inicio) {
  String _string = "";

  if (_fluxoInt < 100) {
    _string.concat("0");
  }
  if (_fluxoInt < 10) {
    _string.concat("0");
  }
  
  _string.concat(_fluxoInt);
  uint32_t _length = _string.length();

  unsigned char _char [168] = {};
  
  PGMReadNumeros(_char, _string[_length - 3] - '0');
  LCD.writeNumber(_char, _inicio);
  
  PGMReadNumeros(_char, _string[_length - 2] - '0');
  LCD.writeNumber(_char, _inicio + 18);

  // simbolo de . (ponto decimal)
  PGMreadSimboloPonto(_char);
  LCD.writeSymbol(_char, _inicio + 35, 2); // 2 colunas no display
  
  PGMReadNumeros(_char, _string[_length - 1] - '0');
  LCD.writeNumber(_char, _inicio + 40);
  
  // simbolo de L/MIN (litro por minuto)
  PGMreadSimboloLMin(_char);
  LCD.writeSymbol(_char, _inicio + 59, 42); // 42 colunas no display
}

// _tempInt deve ser um numero uint32_t formado pela temperatura em float multiplicado por 10, ou seja, a unidade sera exibida como casa decimal
void temperaturaLCD(uint32_t _tempInt, uint8_t _inicio) {
  String _string = "";

  if (_tempInt < 100) {
    _string.concat("0");
  }
  if (_tempInt < 10) {
    _string.concat("0");
  }
  
  _string.concat(_tempInt);
  uint32_t _length = _string.length();

  unsigned char _char [56] = {};
  
  PGMReadNumeros(_char, _string[_length - 3] - '0');
  LCD.writeNumber(_char, _inicio);
  
  PGMReadNumeros(_char, _string[_length - 2] - '0');
  LCD.writeNumber(_char, _inicio + 18);

  // simbolo de . (ponto decimal)
  PGMreadSimboloPonto(_char);
  LCD.writeSymbol(_char, _inicio + 35, 2); // 2 colunas no display
  
  PGMReadNumeros(_char, _string[_length - 1] - '0');
  LCD.writeNumber(_char, _inicio + 40);
  
  // simbolo de ºC (celsius)
  PGMreadSimboloCelsius(_char);
  LCD.writeSymbol(_char, _inicio + 59, 12); // 12 colunas no display
}

// _presaoInt deve ser um numero uint32_t formado pela temperatura em float multiplicado por 10, ou seja, a unidade sera exibida como casa decimal
void pressaoLCD(uint32_t _presaoInt, uint8_t _inicio) {
  String _string = "";

  if (_presaoInt < 100) {
    _string.concat("0");
  }
  if (_presaoInt < 10) {
    _string.concat("0");
  }
  
  _string.concat(_presaoInt);
  uint32_t _length = _string.length();

  unsigned char _char [108] = {};
  
  PGMReadNumeros(_char, _string[_length - 3] - '0');
  LCD.writeNumber(_char, _inicio);
  
  PGMReadNumeros(_char, _string[_length - 2] - '0');
  LCD.writeNumber(_char, _inicio + 18);

  // simbolo de . (ponto decimal)
  PGMreadSimboloPonto(_char);
  LCD.writeSymbol(_char, _inicio + 35, 2); // 2 colunas no display
  
  PGMReadNumeros(_char, _string[_length - 1] - '0');
  LCD.writeNumber(_char, _inicio + 40);
  
  // simbolo de bar
  PGMreadSimboloBar(_char);
  LCD.writeSymbol(_char, _inicio + 59, 27); // 27 colunas no display
}

// ### FINAL DISPLAY ###

// ### INICIO LORA

void enviaLora(String _pacote) {
  LoRa.beginPacket();
  LoRa.print(_pacote);
  LoRa.endPacket();
}

// ### FINAL LORA ###

void setup() {
  #if DEBUG
  Serial.begin(115200);
  delay(10);
  Serial.println(F("\n\nIniciando..."));
  #endif

  pinMode(LCD_LED, OUTPUT);
  digitalWrite(LCD_LED, LOW);

  pinMode(btnPin, INPUT);
  //digitalWrite(btnPin, HIGH); // Pullup externo

  pinMode(pressaoPin, INPUT);

  SPI.begin();

  MAX.begin(MAX35103INT, MAX35103RST, MAX35103CE);

  delay(100);
  if (MAX.reset()) {
    #if DEBUG
    Serial.println(F("MAX35103 Reset OK!"));
    #endif
  }
  else {
    #if DEBUG
    Serial.println(F("ERRO no Reset do MAX35103"));
    #endif
  }

  delay(100);
  MAX.config();

  #if DEBUG
  printConfigMAX();
  #endif

  delay(100);
  if (MAX.toFlash()) {
    #if DEBUG
    Serial.println(F("MAX35103 toFlash OK!"));
    #endif
  }
  else {
    #if DEBUG
    Serial.println(F("ERRO no toFlash do MAX35103"));
    #endif
  }
  
  delay(100);
  if (MAX.initialize()) {
    #if DEBUG
    Serial.println(F("Initialize OK!"));
    #endif
  }
  else {
    #if DEBUG
    Serial.println(F("ERRO no initialize do MAX35103"));
    #endif
  }

  LCD.begin(LCD_SI, LCD_SCL, LCD_A0, LCD_RST, LCD_CS);
  delay(10);
  LCD.clear(0, 128);

  /////////////////////////////////////////////////
  digitalWrite(LCD_LED, HIGH);
  delay(100);

  while (true) {

    unsigned char erros [] = {
    0x00, 0x00, 0x00, 0x80, 0xC0, 0xE0, 0xE0, 0xF0, 0xF0, 0xF8, 0xF8, 0x78, 0x78, 0x78, 0xF8, 0xF8,
    0xF0, 0xF0, 0xE0, 0xE0, 0xC0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0xF8, 0xF8,
    0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0xF8, 0xF8, 0xF8, 0x00, 0x00, 0x00, 0x00, 0xF8,
    0xF8, 0xF8, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0xF8, 0xF8, 0xF8, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0xF8, 0xF8, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38,
    0xF8, 0xF8, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xC0, 0xE0, 0x60, 0x30, 0x30,
    0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x38, 0x30, 0x30, 0x60, 0xE0, 0xC0, 0x80, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xF0, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x3F, 0x3F, 0x3F,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xFF,
    0xFF, 0xFF, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0,
    0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xF0, 0xFC, 0x1F, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x1F, 0xFC, 0xF0,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x07, 0x1F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x18, 0x18, 0x18, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x1F, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xFF,
    0xFF, 0xFF, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x07, 0x1F, 0x7C, 0xE0, 0xC0, 0x80, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x73, 0x73, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xC0, 0xE0, 0x7C, 0x1F, 0x07,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x03, 0x07, 0x07, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F,
    0x07, 0x07, 0x03, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x0F,
    0x0F, 0x0F, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0F, 0x0F, 0x0F, 0x00, 0x00, 0x00,
    0x0E, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E,
    0x0F, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x03, 0x06, 0x06,
    0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0E, 0x06, 0x06, 0x03, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    };

    LCD.writeSymbol(erros, 0, 128);

    while (true);

    volumeLCD(234567);
    delay(3000);
    LCD.clear(0, 128);
    delay(1);

    fluxoLCD(712, 14); // inicio em 14
    delay(3000);
    LCD.clear(0, 128);
    delay(1);

    temperaturaLCD(293, 29); // inicio em 29
    delay(3000);
    LCD.clear(0, 128);
    delay(1);

    pressaoLCD(53, 21); // inicio em 21
    delay(3000);
    LCD.clear(0, 128);
    delay(1);
  }
  
  digitalWrite(LCD_LED, LOW);
  /////////////////////////////////////////////////

  valvula.begin(SW1Pin, SW2Pin, motorSleepPin, motorIN1Pin, motorIN2Pin);
  
  if (valvula.abre()) {
    #if DEBUG
    Serial.println(F("Valvula aberta!"));
    #endif
  }
  else {
    #if DEBUG
    Serial.println(F("ERRO ao abrir valvula!"));
    #endif
  }

  LoRa.setPins(LoRaSS, LoRaRST, LoRaDIO0);

  uint8_t _timeout = 0;
  while (!LoRa.begin(868E6) && _timeout < 15) {
    _timeout++;
    delay(1000);
  }

  #if DEBUG
  if (_timeout >= 15) {
    Serial.println("Falha ao iniciar modulo LoRa!");
  }
  else {
    Serial.println("Modulo LoRa iniciado!");
  }
  #endif

  LoRa.setTxPower(20);

  // Change sync word (0xAF) to match the receiver
  // The sync word assures you don't get LoRa messages from other LoRa transceivers
  // ranges from 0-0xFF
  LoRa.setSyncWord(0xAF);

  #if DEBUG
  Serial.println("Setup OK!");
  #endif
}

void loop() {
  if (millis() > leituraAnterior + 3000) {
    leituraAnterior = millis();

    float _fluxo = 0.0;
    if (MAX.fluxoToFDIff(&_fluxo)) {
      String _pacote = "{t: ";
      _pacote.concat(millis());
      _pacote.concat(", f: ");
      _pacote.concat(_fluxo);
      _pacote.concat("}");
      enviaLora(_pacote);

      #if DEBUG
      Serial.println(_pacote);
      #endif
    }
    else {
      enviaLora("f: ERRO");

      #if DEBUG
      Serial.println(F("Erro ao ler fluxo!"));
      #endif
    }

    /*float _temperatura1 = 0.0;
    if (MAX.temperatura(1, &_temperatura1)) {
      Serial.print(F("Temp1: "));
      Serial.println(_temperatura1, 1);
    }
    else {
      Serial.println(F("Erro ao ler temperatura!"));
    }*/

    /*uint32_t _pressaoAnalog = analogRead(pressaoPin);
    uint32_t _pressaoBarInt = map(_pressaoAnalog, 95, 870, 0, 690);
    float _pressaoBar = (float)_pressaoBarInt / 100.0;

    Serial.print("_pressao: ");
    Serial.print(_pressaoAnalog);
    Serial.print(" | ");
    Serial.print(_pressaoBar);
    Serial.println(" bar");

    if (_pressaoAnalog < 100) {
      Serial.println(F("### Ausencia de agua! ###"));
    }*/
  }

  if (LoRa.parsePacket()) {
    #if DEBUG
    Serial.print("Received packet: ");
    #endif

    String _LoRaData = "";
    while (LoRa.available()) {
      _LoRaData.concat(LoRa.readString());
    }

    #if DEBUG
    Serial.print(_LoRaData); 
    Serial.print(" | RSSI: ");
    Serial.println(LoRa.packetRssi());
    #endif

    if(!_LoRaData.compareTo("v: abre")) {
      if(valvula.abre()) {
        enviaLora("Aberto!");
      }
      else {
        enviaLora("Erro ao abrir!");
      }
    }

    if(!_LoRaData.compareTo("v: fecha")) {
      if(valvula.fecha()) {
        enviaLora("Fechado!");
      }
      else {
        enviaLora("Erro ao fechar!");
      }
    }
  }

  delay(10);
}